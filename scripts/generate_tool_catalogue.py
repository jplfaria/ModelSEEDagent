import datetime
import importlib
import inspect
from pathlib import Path

# This script discovers all modules in src.tools, imports them to ensure
# their classes are registered with ToolRegistry, then renders a Markdown
# table listing every tool name and its description (pulled from the class
# attribute `tool_description`).
#
# Run it with:
#   python scripts/generate_tool_catalogue.py
#
# The output file docs/user-guide/tool-catalogue.md (or a custom path passed
# as CLI argument) is overwritten in-place.

SRC_ROOT = Path(__file__).resolve().parent.parent / "src"
TOOLS_PKG = "src.tools"
OUTPUT_MD = (
    Path(__file__).resolve().parent.parent / "docs" / "user-guide" / "tool-catalogue.md"
)


def import_all_submodules(package_name: str):
    """Import every *.py file under *package_name* safely."""
    import importlib.util

    package = importlib.import_module(package_name)
    package_path = Path(package.__file__).parent
    for py_path in package_path.rglob("*.py"):
        # Construct module name from file path
        rel_path = py_path.relative_to(package_path).with_suffix("")
        parts = [package_name] + [p for p in rel_path.parts]
        modname = ".".join(parts)
        try:
            importlib.import_module(modname)
        except Exception as exc:  # pragma: no cover – we only log
            print(f"[WARN] Skipped {modname}: {exc}")


def build_catalogue() -> str:
    from src.tools.base import ToolRegistry  # noqa: WPS433 – runtime import

    headers = ["Tool", "Description", "Module"]
    rows = []
    for tool_name in sorted(ToolRegistry.list_tools()):
        tool_cls = ToolRegistry.get_tool(tool_name)
        if tool_cls is None:  # pragma: no cover – shouldn't happen
            continue
        desc = getattr(tool_cls, "tool_description", "") or "(no description)"
        module_path = f"{tool_cls.__module__}.{tool_cls.__name__}"
        rows.append((tool_name, desc.strip().replace("\n", " "), module_path))

    # Build Markdown table
    table_lines = [
        "| " + " | ".join(headers) + " |",
        "| " + " | ".join(["---"] * len(headers)) + " |",
    ]
    for tool_name, desc, mod in rows:
        table_lines.append(f"| `{tool_name}` | {desc} | `{mod}` |")

    return "\n".join(
        [
            "# Tool Catalogue (auto-generated)\n",
            "This file is generated by `scripts/generate_tool_catalogue.py`. **Do not** edit manually.\n",
            *table_lines,
            "",
            f"_Total tools: {len(rows)} – last updated: {{}}_".format(
                datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
            ),
        ]
    )


def main():
    import argparse

    parser = argparse.ArgumentParser(description="Generate tool catalogue markdown.")
    parser.add_argument(
        "--out", type=Path, default=OUTPUT_MD, help="Output markdown file"
    )
    args = parser.parse_args()

    # Ensure all tool modules are imported so registry is complete
    import_all_submodules(TOOLS_PKG)

    md = build_catalogue()

    args.out.parent.mkdir(parents=True, exist_ok=True)
    args.out.write_text(md, encoding="utf-8")
    print(
        f"Wrote {args.out.relative_to(Path.cwd())} (tools: {len(md.splitlines()) - 5})"
    )


if __name__ == "__main__":
    main()
